//this mod "holds" all the proto defs that get generated by the include_proto!
//proc macro at compile time. this is why the use statements above it start with this name
/*pub mod chat_client {
    tonic::include_proto!("chatroom"); // The string specified here must match the proto package name
}*/
use proj1::chatroom_data::chat_client::ChatClient;
use proj1::chatroom_data::MessagePacket;
use proj1::chatroom_data::{CreationResult, LoginRequest, LoginResult, LogoutRequest, LogoutResult, User};
use std::error::Error;
use std::time::Duration;
use tokio::time;
use tonic::transport::Channel;
use tonic::Request;
use tokio::io::AsyncBufReadExt;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    //create client and connect to the central sever
    let mut client = ChatClient::connect("http://[::1]:50051").await?;

    //TODO: auth or smth idfk

    //we are going to live in this function until a user wants to disconnect
    run_chatlink(&mut client).await?;

    //once we reach here, the client has attempted to disconnect, so make the deauth call for them implicitly

    Ok(())
}


async fn run_chatlink(client: &mut ChatClient<Channel>) -> Result<(), Box<dyn Error>> {
    //setup an async stdin
    let stdin = tokio::io::stdin();
    let mut reader = tokio::io::BufReader::new(stdin);


    //this ONLY works because read_line is an async function and we await on it. 
    //otherwise the loop will never yield 
    let outbound = async_stream::stream! {
        loop{
            
            println!("enter some input: ");
            let mut buffer = String::new();
            reader.read_line(&mut buffer).await.unwrap();


            yield MessagePacket::new(buffer.clone());
        }
    };


    let response = client.chatlink(Request::new(outbound)).await?;
    let mut inbound = response.into_inner();

    while let Some(note) = inbound.message().await? {
        println!("NOTE = {:?}", note);
    }

    Ok(())
}
