//this mod "holds" all the proto defs that get generated by the include_proto!
//proc macro at compile time. this is why the use statements above it start with this name
pub mod chat_client {
    tonic::include_proto!("chatroom"); // The string specified here must match the proto package name
}
use chat_client::chat_client::ChatClient;
use chat_client::MessagePacket;
use chat_client::{CreationResult, LoginRequest, LoginResult, LogoutRequest, LogoutResult, User};
use std::error::Error;
use std::time::Duration;
use tokio::time;
use tonic::transport::Channel;
use tonic::Request;
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut client = ChatClient::connect("http://[::1]:50051").await?;

    run_chatlink(&mut client).await?;

    Ok(())
}

impl MessagePacket {
    pub fn new() -> MessagePacket {
        Self {}
    }
}

async fn run_chatlink(client: &mut ChatClient<Channel>) -> Result<(), Box<dyn Error>> {
    let start = time::Instant::now();

    let outbound = async_stream::stream! {
        let mut interval = time::interval(Duration::from_secs(1));

        while let time = interval.tick().await {
            let elapsed = time.duration_since(start);
            /*let note = RouteNote {
                location: Some(Point {
                    latitude: 409146138 + elapsed.as_secs() as i32,
                    longitude: -746188906,
                }),
                message: format!("at {:?}", elapsed),
                };*/
                let msg = MessagePacket::new();

            yield msg;
        }
    };

    let response = client.chatlink(Request::new(outbound)).await?;
    let mut inbound = response.into_inner();

    while let Some(note) = inbound.message().await? {
        println!("NOTE = {:?}", note);
    }

    Ok(())
}
