


use crate::chatroom_data::MessagePacket;

//this mod "holds" all the proto defs that get generated by the include_proto!
//proc macro at compile time. this is why the use statements above it start with this name
pub mod chatroom_data {
    tonic::include_proto!("chatroom"); // The string specified here must match the proto package name
}

impl MessagePacket {
    pub fn new(msg: String, user: String) -> MessagePacket {
        Self {
            msg,
            ts: {
                let start = std::time::SystemTime::now();
                let since_the_epoch = start
                    .duration_since(std::time::UNIX_EPOCH)
                    .expect("Time went backwards");
                since_the_epoch.as_secs()
            },
            user,
        }
    }
}


#[cfg(test)]
pub mod tests {
    use std::io::Write;
    use std::process::{Command, Stdio};
    pub fn kill_process(id: i32) {
        nix::sys::signal::kill(
            nix::unistd::Pid::from_raw(id),
            nix::sys::signal::Signal::SIGKILL,
        )
        .expect(&format!("failed to kill process with PID: {}", id))
    }

    pub struct TestEnv {
        server: std::process::Child,
        client_pool: Vec<(std::process::Child, std::process::ChildStdin)>,
    }

    #[derive(Debug)]
    pub struct TestResult {
        server_log: String,
        client_logs: Vec<String>,
    }

    impl TestEnv {
        pub fn send_msg(
            &mut self,
            client: usize,
            msg: String,
        ) -> Result<(), Box<dyn std::error::Error>> {
            self.client_pool[client]
                .1
                .write_all(&format!("{}\n", msg).into_bytes())?;
            self.client_pool[client].1.flush().unwrap();
            //probably unessecary, but give the message time to get to the server and back so we have nice deterministic output for testing
            std::thread::sleep(std::time::Duration::from_millis(500));
            Ok(())
        }

        pub fn kill_client(&mut self, client: usize) {
            self.send_msg(client, "/kill".to_string()).unwrap();
            //self.client_pool.remove(client);
        }

        pub fn end_test(mut self) -> TestResult {
            //kill all clients and gather their logs
            let mut client_logs: Vec<String> = Vec::new();
            for _i in 0..self.client_pool.len() {
                self.kill_client(0);
                let client_output = self.client_pool.remove(0).0.wait_with_output().unwrap();
                client_logs
                    .push(String::from_utf8(client_output.stdout.to_ascii_lowercase()).unwrap());
            }

            //kill server and gather its logs
            kill_process(self.server.id() as i32);
            std::thread::sleep(std::time::Duration::from_millis(1000));
            let server_log = self.server.wait_with_output().unwrap();
            let server_log = server_log.stdout.to_ascii_lowercase();
            let server_log = String::from_utf8(server_log).unwrap();

            TestResult {
                server_log,
                client_logs,
            }
        }

        pub fn add_client(&mut self, port: String) {
            let mut client = Command::new("./target/debug/chatroom-client")
                .arg(format!("{}", self.client_pool.len()))
                .arg(port)
                .stdin(Stdio::piped())
                .stdout(Stdio::piped())
                .spawn()
                .expect("Failed to spawn client 1");

            let client_stdin = client.stdin.take().expect("Failed to open client 1 stdin");

            self.client_pool.push((client, client_stdin))
        }

        pub fn add_client_with_id(&mut self, id: usize,port: String) {
            let mut client = Command::new("./target/debug/chatroom-client")
                .arg(format!("{}", id))
                .arg(port)
                .stdin(Stdio::piped())
                .stdout(Stdio::piped())
                .spawn()
                .expect("Failed to spawn client 1");

            let client_stdin = client.stdin.take().expect("Failed to open client 1 stdin");

            self.client_pool.push((client, client_stdin))
        }
    }

    //start a server and n clients and return the server handle + client process pool
    pub fn boot(num_clients: usize, port:String) -> TestEnv {
        let server = Command::new("./target/debug/chatroom-server")
            .arg(port.clone())
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .spawn()
            .expect("Failed to spawn child process");

        let mut client_pool: Vec<(std::process::Child, std::process::ChildStdin)> = Vec::new();

        for i in 0..num_clients {
            let mut client = Command::new("./target/debug/chatroom-client")
                .arg(format!("{}", i))
                .arg(port.clone())
                .stdin(Stdio::piped())
                .stdout(Stdio::piped())
                .spawn()
                .expect("Failed to spawn client 1");

            let client_stdin = client.stdin.take().expect("Failed to open client 1 stdin");

            client_pool.push((client, client_stdin));
        }

        TestEnv {
            server,
            client_pool,
        }
    }

    //test 1 - basic pingpong
    //client sends several messages, and receives them
    //server receives the messages from the client
    #[test]
    pub fn driver_test_1() {
        let mut test_env = boot(1,"50051".to_string());

        let client_1_inputs = vec!["hey", "hi", "hello"];

        for line in &client_1_inputs {
            test_env.send_msg(0, line.to_string()).unwrap();
        }

        let res = test_env.end_test();

        //this does not actually outpu if you dont run cargo test with --nocapture
        println!("{:?}", res);

        let mut server_test = true;
        for line in &client_1_inputs {
            if !res
                .server_log
                .contains(&format!("user [0] says {{{}}}", line).to_string())
            {
                server_test = false
            }
        }

        let mut client_test = true;
        for line in &client_1_inputs {
            if !res.client_logs[0].contains(&format!("[0]:{}", line)) {
                client_test = false;
            }
        }

        assert!(server_test);
        assert!(client_test);
        std::thread::sleep(std::time::Duration::from_millis(5000));
    }

    //test 2 - concurrently online
    //server start , both clients start
    //both clients send messages
    //both clients get all messages
    //server got all messages from both clients
    #[test]
    pub fn driver_test_2() {
        let mut test_env = boot(2,"50052".to_string());
        let client_1_inputs = vec!["hey", "hi", "hello"];
        let client_2_inputs = vec!["foo", "bar", "baz"];

        for line in &client_1_inputs {
            test_env.send_msg(0, line.to_string()).unwrap();
        }
        for line in &client_2_inputs {
            test_env.send_msg(1, line.to_string()).unwrap();
        }

        let res = test_env.end_test();

        //this does not actually outpu if you dont run cargo test with --nocapture
        println!("{:?}", res);

        let mut server_test = true;
        for line in &client_1_inputs {
            if !res
                .server_log
                .contains(&format!("user [0] says {{{}}}", line).to_string())
            {
                server_test = false
            }
        }
        for line in &client_2_inputs {
            if !res
                .server_log
                .contains(&format!("user [1] says {{{}}}", line).to_string())
            {
                server_test = false
            }
        }

        let mut client_test = true;
        //make sure both clients saw all of client 0's messages
        for line in &client_1_inputs {
            if !res.client_logs[0].contains(&format!("[0]:{}", line)) {
                client_test = false;
            }
            if !res.client_logs[1].contains(&format!("[0]:{}", line)) {
                client_test = false;
            }
        }
        //make sure both clients saw all of client 1's messages
        for line in &client_2_inputs {
            if !res.client_logs[0].contains(&format!("[1]:{}", line)) {
                client_test = false;
            }
            if !res.client_logs[0].contains(&format!("[1]:{}", line)) {
                client_test = false;
            }
        }
        assert!(client_test);
        assert!(server_test);
        std::thread::sleep(std::time::Duration::from_millis(5000));
    }

    //test 3 - old messages sent to new users
    //server start, client 1 start
    //client 1 sends messages
    //client 2 comes online
    //client 2 should recieve all messages that client 1 sent
    #[test]
    pub fn driver_test_3() {
        let mut test_env = boot(1,"50053".to_string());
        let client_1_inputs = vec!["hey", "hi", "hello"];

        for line in &client_1_inputs {
            test_env.send_msg(0, line.to_string()).unwrap();
        }

        test_env.add_client("50053".to_string());

        let res = test_env.end_test();
        //this does not actually outpu if you dont run cargo test with --nocapture
        println!("{:?}", res);

        let mut client_test = true;
        for line in &client_1_inputs {
            if !(res.client_logs[0].contains(&format!("[0]:{}", line))
                && res.client_logs[1].contains(&format!("[0]:{}", line)))
            {
                client_test = false;
            }
        }

        assert!(client_test);
        std::thread::sleep(std::time::Duration::from_millis(5000));

    }

    //test 4 - ONLY unreads are sent to reconnecting users
    //server starts, client 1+2 connect
    //client 1 sends messages
    //client one disconnects
    //client 2 sends messages
    //client 1 reconnects under same name
    //client 1 logs should contain its initial messages ONLY ONCE, as well as the messages sent by client 2 after it disconnected
    #[test]
    pub fn driver_test_4() {
        let mut test_env = boot(2,"50054".to_string());
        let client_1_inputs = vec!["hey", "hi", "hello"];
        let client_2_inputs = vec!["foo", "bar", "baz"];

        for line in &client_1_inputs {
            test_env.send_msg(0, line.to_string()).unwrap();
        }
        test_env.kill_client(0);
        let first_session_client_output =
            test_env.client_pool.remove(0).0.wait_with_output().unwrap();

        for line in &client_2_inputs {
            //client "2" is now at index 0 since we killed the first client
            test_env.send_msg(0, line.to_string()).unwrap();
        }

        test_env.add_client_with_id(0,"50054".to_string());
        let res = test_env.end_test();

        println!("{:?}", first_session_client_output);
        println!("{:?}", res);

        let mut client_test = true;
        for line in &client_1_inputs {
            if !String::from_utf8(first_session_client_output.stdout.to_ascii_lowercase())
                .unwrap()
                .contains(&format!("[0]:{}", line))
            {
                client_test = false;
            }
        }
        for line in &client_2_inputs {
            if !(res.client_logs[1].contains(&format!("[1]:{}", line))) {
                client_test = false;
            }
        }

        for line in &client_1_inputs {
            if !(res.client_logs[0].contains(&format!("[0]:{}", line))) {
                client_test = false;
            }
        }
        for line in &client_2_inputs {
            if !(res.client_logs[0].contains(&format!("[1]:{}", line))) {
                client_test = false;
            }
        }

        assert!(client_test);
        std::thread::sleep(std::time::Duration::from_millis(5000));
        //we're just assuming the server is fine because it was fine in all the other tets
    }
}
